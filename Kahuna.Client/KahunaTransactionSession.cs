
using System.Text;
using Kahuna.Shared.KeyValue;
using Kommander.Time;

namespace Kahuna.Client;

/// <summary>
/// Represents a transaction session within the Kahuna key-value storage system.
/// It provides methods to perform operations such as setting, getting, committing,
/// and rolling back key-value pairs within the context of a transactional session.
/// </summary>
/// <remarks>
/// The KahunaTransactionSession class supports both single-step and multi-step key-value transactions
/// which may include locking mechanisms and durability preferences depending on the setup.
/// </remarks>
public class KahunaTransactionSession : IAsyncDisposable
{
    /// <summary>
    /// Gets the instance of the KahunaClient used by the current KahunaTransactionSession.
    /// This property encapsulates the client responsible for handling communication and operations within the transaction context.
    /// </summary>
    private KahunaClient Client { get; }

    /// <summary>
    /// Gets the URL associated with the current KahunaTransactionSession.
    /// This property specifies the endpoint used for managing transaction-related communications.
    /// </summary>
    private string Url { get; }

    /// <summary>
    /// Gets the unique identifier for the current KahunaTransactionSession instance.
    /// This unique id allows to consistently identify and redirect the transaction session
    /// to the appropiate transaction coordinator node.
    /// </summary>
    private string UniqueId { get; }

    /// <summary>
    /// Gets or sets the locking mechanism used within the current KahunaTransactionSession.
    /// This property determines whether the transaction operates under a pessimistic or optimistic locking strategy, influencing how data consistency and concurrency are managed.
    /// </summary>
    private KeyValueTransactionLocking Locking { get; set; } = KeyValueTransactionLocking.Pessimistic;

    /// <summary>
    /// Gets or sets the current status of the transaction session.
    /// This property indicates whether the transaction is pending, committed, or rolled back,
    /// allowing the state of the transaction to be monitored and validated during operations.
    /// </summary>
    private KahunaTransactionStatus Status { get; set; } = KahunaTransactionStatus.Pending;

    /// <summary>
    /// Gets the unique identifier for the current transaction generated by the transaction coordinator.
    /// This identifier is used to track and validate operations performed within the same transaction scope.
    /// </summary>
    public HLCTimestamp TransactionId { get; }
    
    /// <summary>
    /// Prevents simultaneous commits/rollbacks in the transaction session.
    /// </summary>
    private readonly SemaphoreSlim semaphore = new(1, 1);

    /// <summary>
    /// A set of acquired locks within the transaction session.
    /// </summary>
    private HashSet<(string, KeyValueDurability)>? acquiredLocks;
    
    /// <summary>
    /// A set of modified keys within the transaction session.
    /// </summary>
    private HashSet<(string, KeyValueDurability)>? modifiedKeys;

    private bool disposed;
    
    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="client"></param>
    /// <param name="url"></param>
    /// <param name="uniqueId"></param>
    /// <param name="transactionId"></param>
    /// <param name="locking"></param> 
    public KahunaTransactionSession(KahunaClient client, string url, string uniqueId, HLCTimestamp transactionId, KeyValueTransactionLocking locking)
    {
        Client = client;
        Url = url;
        UniqueId = uniqueId;
        TransactionId = transactionId;
        Locking = locking;
    }
    
    /// <summary>
    /// Set key to hold the string value. If key already holds a value, it is overwritten
    /// </summary>
    /// <param name="key"></param>
    /// <param name="value"></param>
    /// <param name="expiryTime"></param>
    /// <param name="durability"></param>
    /// <returns></returns>
    public async Task<KahunaKeyValue> SetKeyValue(
        string key, 
        byte[]? value, 
        int expiryTime = 0, 
        KeyValueFlags flags = KeyValueFlags.Set, 
        KeyValueDurability durability = KeyValueDurability.Persistent, 
        CancellationToken cancellationToken = default
    )
    {       
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TrySetKeyValue(
            Url,
            TransactionId,
            key,
            value,
            expiryTime,
            flags,
            durability,
            cancellationToken
        ).ConfigureAwait(false);

        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }

        return new(Client, key, success, value, revision, durability, timeElapsedMs);        
    }
    
    /// <summary>
    /// Set key to hold the string value. If key already holds a value, it is overwritten
    /// </summary>
    /// <param name="key"></param>
    /// <param name="value"></param>
    /// <param name="expiryTime"></param>
    /// <param name="durability"></param>
    /// <returns></returns>
    public async Task<KahunaKeyValue> SetKeyValue(
        string key, 
        string value, 
        int expiryTime = 0, 
        KeyValueFlags flags = KeyValueFlags.Set, 
        KeyValueDurability durability = KeyValueDurability.Persistent, 
        CancellationToken cancellationToken = default
    )
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        byte[] valueBytes = Encoding.UTF8.GetBytes(value);
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TrySetKeyValue(
            Url, 
            TransactionId,
            key, 
            valueBytes, 
            expiryTime, 
            flags, 
            durability, 
            cancellationToken
        ).ConfigureAwait(false);
        
        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }
        
        return new(Client, key, success, valueBytes, revision, durability, timeElapsedMs);
    }
    
    /// <summary>
    /// Sets a key-value pair in the storage with optional expiration and durability settings.
    /// If key already holds a value, it is overwritten.
    /// </summary>
    /// <param name="key">The key to be stored.</param>
    /// <param name="value">The value to be associated with the key. Can be null.</param>
    /// <param name="expiry">The expiration time for the key-value pair. Set to zero for no expiration.</param>
    /// <param name="flags">Flags indicating conditions for setting the key. Default is 'Set'.</param>
    /// <param name="durability">Specifies the durability of the key-value pair. Default is 'Persistent'.</param>
    /// <param name="cancellationToken">A token to cancel the operation if required.</param>
    /// <returns>A task representing the asynchronous operation. The task result contains the key-value pair information after the operation.</returns>
    public async Task<KahunaKeyValue> SetKeyValue(
        string key, 
        byte[]? value, 
        TimeSpan expiry, 
        KeyValueFlags flags = KeyValueFlags.Set, 
        KeyValueDurability durability = KeyValueDurability.Persistent,
        CancellationToken cancellationToken = default
    )
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
                       
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TrySetKeyValue(
            Url, 
            TransactionId,
            key, 
            value, 
            (int)expiry.TotalMilliseconds, 
            flags, 
            durability, 
            cancellationToken
        ).ConfigureAwait(false);
        
        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }
        
        return new(Client, key, success, value, revision, durability, timeElapsedMs);
    }
    
    /// <summary>
    /// Compare-Value-And-Swap (CVAS) operation. 
    /// Attempts to compare a specified value with the current value associated with a key
    /// and, if they match, sets the key to a new value with an optional expiry time and durability setting.
    /// </summary>
    /// <param name="key">The key to be accessed or updated.</param>
    /// <param name="value">The new value to set if the comparison succeeds.</param>
    /// <param name="compareValue">The value to compare against the current value associated with the key.</param>
    /// <param name="expiryTime">The expiration time (in milliseconds) for the key-value pair. Default is 30000 milliseconds.</param>
    /// <param name="durability">Specifies whether the key-value pair is ephemeral or persistent. Default is persistent.</param>
    /// <param name="cancellationToken">Token used to propagate notification that operations should be canceled.</param>
    /// <returns>
    /// An instance of <see cref="KahunaKeyValue"/> that provides details about the operation,
    /// including whether it succeeded, the updated value, revision, and timing information.
    /// </returns>
    public async Task<KahunaKeyValue> TryCompareValueAndSetKeyValue(
        string key, 
        byte[] value, 
        byte[] compareValue, 
        int expiryTime = 30000, 
        KeyValueDurability durability = KeyValueDurability.Persistent,
        CancellationToken cancellationToken = default
    )
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TryCompareValueAndSetKeyValue(
            Url, 
            TransactionId,
            key, 
            value, 
            compareValue, 
            expiryTime, 
            durability, 
            cancellationToken
        ).ConfigureAwait(false);
        
        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }
        
        return new(Client, key, success, value, revision, durability, timeElapsedMs);
    }
    
    /// <summary>
    /// Compare-Value-and-Swap (CVAS) operation. 
    /// Attempts to compare a specified value with the current value associated with a key
    /// and, if they match, sets the key to a new value with an optional expiry time and durability setting.
    /// </summary>
    /// <param name="key">The key to be accessed or updated.</param>
    /// <param name="value">The new value to set if the comparison succeeds.</param>
    /// <param name="compareValue">The value to compare against the current value associated with the key.</param>
    /// <param name="expiryTime">The expiration time (in milliseconds) for the key-value pair. Default is 30000 milliseconds.</param>
    /// <param name="durability">Specifies whether the key-value pair is ephemeral or persistent. Default is persistent.</param>
    /// <param name="cancellationToken">Token used to propagate notification that operations should be canceled.</param>
    /// <returns>
    /// An instance of <see cref="KahunaKeyValue"/> that provides details about the operation,
    /// including whether it succeeded, the updated value, revision, and timing information.
    /// </returns>
    /// <summary>       
    public async Task<KahunaKeyValue> TryCompareValueAndSetKeyValue(
        string key, 
        string value, 
        string compareValue, 
        int expiryTime = 0, 
        KeyValueDurability durability = KeyValueDurability.Persistent, 
        CancellationToken cancellationToken = default
    )
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        byte[] valueBytes = Encoding.UTF8.GetBytes(value);
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TryCompareValueAndSetKeyValue(
            Url, 
            TransactionId,
            key, 
            valueBytes, 
            Encoding.UTF8.GetBytes(compareValue), 
            expiryTime, 
            durability,
            cancellationToken
        ).ConfigureAwait(false);
        
        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }
        
        return new(Client, key, success, valueBytes, revision, durability, timeElapsedMs);
    }

    /// <summary>
    /// Compare-Revision-And-Swap (CRAS) operation. 
    /// Attempts to compare the current revision of a key and set its value if the revision matches the provided value.
    /// </summary>
    /// <param name="key">The key for which the operation is to be performed.</param>
    /// <param name="value">The value to set if the revision comparison succeeds.</param>
    /// <param name="compareRevision">The revision to compare against the current revision of the key.</param>
    /// <param name="expiryTime">The expiration time in milliseconds for the key-value pair. Defaults to 0, which implies no expiration.</param>
    /// <param name="durability">Specifies the durability type for the key. Either Persistent or Ephemeral.</param>
    /// <param name="cancellationToken">Token to observe while waiting for the task to complete. This allows the operation to be canceled.</param>
    /// <returns>A task that resolves to a <see cref="KahunaKeyValue"/> object representing the result of the operation.</returns>
    public async Task<KahunaKeyValue> TryCompareRevisionAndSetKeyValue(
        string key, 
        byte[]? value, 
        long compareRevision, 
        int expiryTime = 0, 
        KeyValueDurability durability = KeyValueDurability.Persistent,
        CancellationToken cancellationToken = default
    )
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);

        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TryCompareRevisionAndSetKeyValue(
            Url, 
            TransactionId,
            key, 
            value, 
            compareRevision, 
            expiryTime, 
            durability,
            cancellationToken
        ).ConfigureAwait(false);
        
        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }
        
        return new(Client, key, success, value, revision, durability, timeElapsedMs);
    }

    /// <summary>
    /// Compare-Revision-and-Swap (CRAS) operation
    /// Attempts to compare the current revision of a key with a specified revision and set a new value if they match.
    /// </summary>
    /// <param name="key">The key to be updated.</param>
    /// <param name="value">The new value to be set.</param>
    /// <param name="compareRevision">The revision value to compare against.</param>
    /// <param name="expiryTime">The time-to-live in seconds for the key-value pair. Defaults to 0 for no expiration.</param>
    /// <param name="durability">The durability level of the key-value pair (Persistent or Ephemeral). Defaults to Persistent.</param>
    /// <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    /// <returns>A <see cref="KahunaKeyValue"/> instance containing information about the operation result, including success status, revision, and elapsed time.</returns>
    public async Task<KahunaKeyValue> TryCompareRevisionAndSetKeyValue(
        string key, 
        string value, 
        long compareRevision, 
        int expiryTime = 0, 
        KeyValueDurability durability = KeyValueDurability.Persistent,
        CancellationToken cancellationToken = default
    )
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        byte[] valueBytes = Encoding.UTF8.GetBytes(value);
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TryCompareRevisionAndSetKeyValue(
            Url,
            TransactionId,
            key, 
            valueBytes, 
            compareRevision, 
            expiryTime, 
            durability,
            cancellationToken
        ).ConfigureAwait(false);
        
        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }
        
        return new(Client, key, success, valueBytes, revision, durability, timeElapsedMs);
    }
    
    /// <summary>
    /// Retrieves a key-value pair from the server. If the key does not exist null is returned
    /// </summary>
    /// <param name="key">The key to identify the requested value.</param>
    /// <param name="durability">The specified durability level of the key-value pair, default is persistent.</param>
    /// <param name="cancellationToken">A token to propagate notifications that the operation should be canceled.</param>
    /// <returns>A task that represents the asynchronous operation, which returns a <see cref="KahunaKeyValue"/> containing the key-value information.</returns>
    public async Task<KahunaKeyValue> GetKeyValue(string key, KeyValueDurability durability = KeyValueDurability.Persistent, CancellationToken cancellationToken = default)
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        (bool success, byte[]? value, long revision, int timeElapsedMs) = await Client.Communication.TryGetKeyValue(
            Url, 
            TransactionId,
            key, 
            -1, 
            durability, 
            cancellationToken
        ).ConfigureAwait(false);
        
        return new(Client, key, success, value, revision, durability, timeElapsedMs);
    }
    
    /// <summary>
    /// Checks whether a key exists in the key-value store with the specified durability and returns the associated metadata.
    /// </summary>
    /// <param name="key">The key to check for existence.</param>
    /// <param name="durability">The durability level to check the key against. Defaults to <see cref="KeyValueDurability.Persistent"/>.</param>
    /// <param name="cancellationToken">A token to signal request cancellation.</param>
    /// <returns>A <see cref="KahunaKeyValue"/> object containing the key's metadata, including success status and revision number.</returns>
    public async Task<KahunaKeyValue> ExistsKeyValue(string key, KeyValueDurability durability = KeyValueDurability.Persistent, CancellationToken cancellationToken = default)
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TryExistsKeyValue(
            Url,
            TransactionId,
            key, 
            -1, 
            durability, 
            cancellationToken
        ).ConfigureAwait(false);
        
        return new(Client, key, success, revision, durability, timeElapsedMs);
    }
    
    /// <summary>
    /// Extends the expiration time of an existing key-value pair in the storage system.
    /// </summary>
    /// <param name="key">The key of the key-value pair to be extended.</param>
    /// <param name="expiresMs">The new expiration time in milliseconds.</param>
    /// <param name="durability">The desired durability setting for the key-value pair, such as persistent or ephemeral.</param>
    /// <param name="cancellationToken">A token to monitor for cancellation requests.</param>
    /// <returns>A <see cref="KahunaKeyValue"/> object representing the result of the extension operation, including success status, revision, and other metadata.</returns>
    public async Task<KahunaKeyValue> ExtendKeyValue(
        string key,
        int expiresMs,
        KeyValueDurability durability = KeyValueDurability.Persistent,
        CancellationToken cancellationToken = default
    )
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TryExtendKeyValue(
            Url, 
            TransactionId,
            key, 
            expiresMs, 
            durability, 
            cancellationToken
        ).ConfigureAwait(false);
        
        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }
        
        return new(Client, key, success, revision, durability, timeElapsedMs);
    }

    /// <summary>
    /// Extends the expiration time of an existing key-value entry in the database.
    /// </summary>
    /// <param name="key">The key of the key-value entry to extend.</param>
    /// <param name="expiresMs">The new expiration duration for the key-value entry.</param>
    /// <param name="durability">The level of durability for the key-value entry. Default is Persistent.</param>
    /// <param name="cancellationToken">Token used to propagate notification that the operation should be canceled.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the updated key-value entry.</returns>
    public async Task<KahunaKeyValue> ExtendKeyValue(
        string key,
        TimeSpan expiresMs,
        KeyValueDurability durability = KeyValueDurability.Persistent,
        CancellationToken cancellationToken = default
    )
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot perform actions on a completed transaction.", KeyValueResponseType.Errored);
        
        if (Locking == KeyValueTransactionLocking.Pessimistic)
        {
            acquiredLocks ??= [];

            if (!acquiredLocks.Contains((key, durability)))
            {
                bool successLock = await Client.Communication.TryAcquireExclusiveKeyValueLock(Url, TransactionId, key, durability, cancellationToken);
                if (successLock)
                    acquiredLocks.Add((key, durability));
            }
        }
        
        (bool success, long revision, int timeElapsedMs) = await Client.Communication.TryExtendKeyValue(
            Url, 
            TransactionId,
            key, 
            (int)expiresMs.TotalMilliseconds, 
            durability, 
            cancellationToken
        ).ConfigureAwait(false);
        
        if (success)
        {
            modifiedKeys ??= [];
            modifiedKeys.Add((key, durability));
        }
        
        return new(Client, key, success, revision, durability, timeElapsedMs);
    }
    
    /// <summary>
    /// Get keys with a specific prefix
    /// </summary>
    /// <param name="prefixKey"></param>
    /// <param name="durability"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    public async Task<(bool, List<string>)> GetByPrefix(string prefixKey, KeyValueDurability durability, CancellationToken cancellationToken = default)
    {
        /// @todo try to acquire lock on prefixKey
        
        return await Client.Communication.GetByPrefix(
            Url, 
            prefixKey, 
            durability, 
            cancellationToken
        ).ConfigureAwait(false);
    }

    /// <summary>
    /// Commits the current transaction session if the transaction status is pending.
    /// </summary>
    /// <param name="cancellationToken">A cancellation token that can be used to observe cancellation requests.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <exception cref="KahunaException">
    /// Thrown if the transaction is not in the pending state or if an error occurs during the commit operation.
    /// </exception>
    public async Task<bool> Commit(CancellationToken cancellationToken = default)
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot commit a transaction that is not pending.", KeyValueResponseType.Errored);
        
        try
        {
            await semaphore.WaitAsync(cancellationToken).ConfigureAwait(false);
            
            if (Status != KahunaTransactionStatus.Pending)
                throw new KahunaException("Cannot commit a transaction that is not pending.", KeyValueResponseType.Errored);
            
            List<KeyValueTransactionModifiedKey> acquiredKeysList;;

            if (acquiredLocks is not null)
            {
                acquiredKeysList = new(acquiredLocks.Count);
                
                foreach ((string key, KeyValueDurability durability) in acquiredLocks)
                    acquiredKeysList.Add(new() { Key = key, Durability = durability});
            }
            else
            {
                acquiredKeysList = [];
            }
            
            List<KeyValueTransactionModifiedKey> modifiedKeysList;

            if (modifiedKeys is not null)
            {
                modifiedKeysList = new(modifiedKeys.Count);
                
                foreach ((string key, KeyValueDurability durability) in modifiedKeys)
                    modifiedKeysList.Add(new() { Key = key, Durability = durability});
            }
            else
            {
                modifiedKeysList = [];
            }
            
            bool result = await Client.Communication.CommitTransactionSession(
                Url,
                UniqueId,
                TransactionId,
                acquiredKeysList,
                modifiedKeysList,
                cancellationToken
            ).ConfigureAwait(false);
            
            if (result)
                Status = KahunaTransactionStatus.Committed;
            
            return result;
        }
        finally
        {
            semaphore.Release();
        }
    }

    /// <summary>
    /// Rolls back the current transaction session, reverting all modifications made during the session.
    /// </summary>
    /// <param name="cancellationToken">A token that can be used to cancel the rollback operation.</param>
    /// <returns>A task that represents the asynchronous rollback operation.</returns>
    public async Task<bool> Rollback(CancellationToken cancellationToken = default)
    {
        if (Status != KahunaTransactionStatus.Pending)
            throw new KahunaException("Cannot rollback a transaction that is not pending.", KeyValueResponseType.Errored);

        try
        {
            await semaphore.WaitAsync(cancellationToken).ConfigureAwait(false);

            if (Status != KahunaTransactionStatus.Pending)
                throw new KahunaException("Cannot rollback a transaction that is not pending.", KeyValueResponseType.Errored);
            
            List<KeyValueTransactionModifiedKey> acquiredKeysList;;

            if (acquiredLocks is not null)
            {
                acquiredKeysList = new(acquiredLocks.Count);
                
                foreach ((string key, KeyValueDurability durability) in acquiredLocks)
                    acquiredKeysList.Add(new() { Key = key, Durability = durability});
            }
            else
            {
                acquiredKeysList = [];
            }
            
            List<KeyValueTransactionModifiedKey> modifiedKeysList;

            if (modifiedKeys is not null)
            {
                modifiedKeysList = new(modifiedKeys.Count);
                
                foreach ((string key, KeyValueDurability durability) in modifiedKeys)
                    modifiedKeysList.Add(new() { Key = key, Durability = durability});
            }
            else
            {
                modifiedKeysList = [];
            }

            bool result = await Client.Communication.RollbackTransactionSession(
                Url,
                UniqueId,
                TransactionId,
                acquiredKeysList,
                modifiedKeysList,
                cancellationToken
            ).ConfigureAwait(false);

            if (result)
                Status = KahunaTransactionStatus.Rolledback;

            return result;
        }
        finally
        {
            semaphore.Release();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (disposed)
            return;

        disposed = true;
        
        GC.SuppressFinalize(this);
        
        if (Status == KahunaTransactionStatus.Pending)
            await Rollback().ConfigureAwait(false);
        
        semaphore.Dispose();
    }
}